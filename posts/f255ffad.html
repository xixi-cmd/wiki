<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>docker</title><meta name="description" content="私のすべてを支配してください"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="https://upimage.alexhchu.com/2021/04/28/5a7401f88c1cf.png"><link rel="stylesheet" href="/xx/style/common/bulma.css"><link rel="stylesheet" href="/xx/style/base.css"><link rel="stylesheet" href="/xx/style/common/helper.css"><script src="/xx/js/common.js"></script><link rel="stylesheet" href="/xx/style/post.css"><link rel="stylesheet" href="/xx/style/themes/highlight-theme-light.css"><script src="/xx/js/highlight.pack.js"></script><meta name="description" content="Docker是一个开源的容器引擎，它可以帮助我们更快地交付应用。Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用Docker，可更快地打包、测试以及部署应用程序，并可减少从编写到部署运行代码的周期。


准备工作官网有详细的安装教程，然后配置下加速器即可，我这边使用阿里云的docker镜像加速器。
基本命令镜像命令# 查询镜像
docker search nginx

# 下载镜像
docker pull nginx

# 列出镜像
docker images
docker images java
docker images java:8
docker images --digests
docker images --filter &amp;quot;dangling=true&amp;.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/xx/">AIENS.'s blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">docker</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/xx/">首页</a></h3><h3 class="is-inline-block"><a href="/xx/about">关于</a></h3><h3 class="is-inline-block"><a href="/xx/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/xx/">首页</a></h3><h3 class="is-inline-block"><a href="/xx/about">关于</a></h3><h3 class="is-inline-block"><a href="/xx/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">新建并启动容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">列出容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">停止容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">强制停止容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">启动已停止的容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">重启容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">进入容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-text">删除容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">导出容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">导入容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile"><span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">基本指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ADD-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">ADD 复制文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ARG-%E8%AE%BE%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><span class="toc-text">ARG 设置构建参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">CMD 容器启动命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COPY-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">COPY 复制文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENTRYPOINT-%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-text">ENTRYPOINT 入口点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENV-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">ENV 设置环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EXPOSE-%E5%A3%B0%E6%98%8E%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-text">EXPOSE 声明暴露的端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FROM-%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="toc-text">FROM 指定基础镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LABEL-%E4%B8%BA%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">LABEL 为镜像添加元数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MAINTAINER-%E6%8C%87%E5%AE%9A%E7%BB%B4%E6%8A%A4%E8%80%85%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%88%E5%B7%B2%E8%BF%87%E6%97%B6%EF%BC%89"><span class="toc-text">MAINTAINER 指定维护者的信息（已过时）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RUN-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">RUN 执行命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#USER-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7"><span class="toc-text">USER 设置用户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VOLUME-%E6%8C%87%E5%AE%9A%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="toc-text">VOLUME 指定挂载点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WORKDIR-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">WORKDIR 指定工作目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="toc-text">相关链接</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/xx/tags/linux"><i class="tag post-item-tag">linux</i></a><a href="/xx/tags/docker"><i class="tag post-item-tag">docker</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">docker</h1><time class="has-text-grey" datetime="2021-05-14T12:31:57.960Z">2021-05-14</time><article class="mt-2 post-content"><p>Docker是一个开源的<strong>容器引擎</strong>，它可以帮助我们更快地交付应用。Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用Docker，可更快地打包、测试以及部署应用程序，并可<strong>减少从编写到部署运行代码的周期</strong>。</p>
<span id="more"></span>

<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>官网有详细的安装教程，然后配置下加速器即可，我这边使用<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-qingdao/instances/mirrors">阿里云的<code>docker</code>镜像加速器</a>。</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><pre><code class="shell"># 查询镜像
docker search nginx

# 下载镜像
docker pull nginx

# 列出镜像
docker images
docker images java
docker images java:8
docker images --digests
docker images --filter &quot;dangling=true&quot;   # 展示虚悬镜像

# 删除本地镜像
docker rmi hello-world
docker rmi -f $(docker images)

# 保存镜像
docker save busybox &gt; busybox.tar
docker save --output busybox.tar busybox

# 加载镜像
docker load &lt; busybox.tar.gz
docker load --input fedora.tar

# 构建镜像
docker build [OPTIONS] PATH | URL | -

</code></pre>
<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><h5 id="新建并启动容器-重要"><a href="#新建并启动容器-重要" class="headerlink" title="新建并启动容器[重要]"></a>新建并启动容器[重要]</h5><p>使用以下<code>docker run</code> 命令即可新建并启动一个容器。该命令是我们最常用的命令了，它有很多选项，下面笔者列举一些常用的选项。</p>
<p>① -d选项：表示后台运行</p>
<p>② -P选项：随机端口映射</p>
<p>③ -p选项：指定端口映射，有以下四种格式。</p>
<p><code>ip:hostPort:containerPort</code></p>
<p><code>ip::containerPort</code></p>
<p><code>hostPort:containerPort</code></p>
<p><code>containerPort</code></p>
<p>④ –network选项：指定网络模式，该选项有以下可选参数：</p>
<p><code>–network=bridge</code>： 默认选项，表示连接到默认的网桥。</p>
<p><code>–network=host</code>：容器使用宿主机的网络。</p>
<p><code>–network=container:NAME_or_ID</code>：告诉Docker让新建的容器使用已有容器的网络配置。</p>
<p><code>–network=none</code>：不配置该容器的网络，用户可自定义网络配置。</p>
<p>示例1：</p>
<pre><code class="shell">docker run java /bin/echo &#39;Hello World&#39;
</code></pre>
<p>这样终端会打印<code>Hello World</code>的字样，跟在本地直接执行<code>/bin/echo &#39;Hello World&#39;</code> 一样。</p>
<p>示例2：</p>
<pre><code class="shell">docker run -d -p 91:80 nginx
</code></pre>
<p>这样就能启动一个<code>Nginx</code>容器。在本例中，我们为<code>docker run</code>添加了两个参数，含义如下：</p>
<pre><code class="shell">-d                           # 后台运行-p 宿主机端口:容器端口         # 开放容器端口到宿主机端口
</code></pre>
<p>访问<a target="_blank" rel="noopener" href="http://docker宿主机ip:91/">http://Docker宿主机IP:91/</a> </p>
<p><strong>TIPS</strong></p>
<p>需要注意的是，使用docker run命令创建容器时，会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像，Docker就会自动从Docker Hub下载镜像并启动一个Docker容器。</p>
<h5 id="列出容器-重要"><a href="#列出容器-重要" class="headerlink" title="列出容器[重要]"></a>列出容器[重要]</h5><p>使用<code>docker ps</code> 命令即可列出运行中的容器。执行该命令后，可看到类似于如下的表格。</p>
<pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES784fd3b294d7        nginx               &quot;nginx -g &#39;daemon off&quot;   20 minutes ago      Up 2 seconds        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes
</code></pre>
<p>如需列出所有容器（包括已停止的容器），可使用-a参数。</p>
<p>该表格包含了七列，含义如下：</p>
<p>① CONTAINER_ID：表示容器ID。</p>
<p>② IMAGE：表示镜像名称。</p>
<p>③ COMMAND：表示启动容器时运行的命令。</p>
<p>④ CREATED：表示容器的创建时间。</p>
<p>⑤ STATUS：表示容器运行的状态。Up表示运行中，Exited表示已停止。</p>
<p>⑥ PORTS：表示容器对外的端口号。</p>
<p>⑦ NAMES：表示容器名称。该名称默认由Docker自动生成，也可使用docker run命令的–name选项自行指定。</p>
<p>命令格式：</p>
<pre><code class="shell">docker ps [OPTIONS]
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--all, -a</code></td>
<td align="left"><code>false</code></td>
<td align="left">列出所有容器，包括未运行的容器，默认只展示运行的容器</td>
</tr>
<tr>
<td align="left"><code>--filter, -f</code></td>
<td align="left"></td>
<td align="left">根据条件过滤显示内容</td>
</tr>
<tr>
<td align="left"><code>--format</code></td>
<td align="left"></td>
<td align="left">通过Go语言模板文件展示镜像</td>
</tr>
<tr>
<td align="left"><code>--last, -n</code></td>
<td align="left"><code>-1</code></td>
<td align="left">显示最近创建n个容器（包含所有状态）</td>
</tr>
<tr>
<td align="left"><code>--latest, -l</code></td>
<td align="left"><code>false</code></td>
<td align="left">显示最近创建的容器（包含所有状态）</td>
</tr>
<tr>
<td align="left"><code>--no-trunc</code></td>
<td align="left"><code>false</code></td>
<td align="left">不截断输出</td>
</tr>
<tr>
<td align="left"><code>--quiet, -q</code></td>
<td align="left"><code>false</code></td>
<td align="left">静默模式，只展示容器的编号</td>
</tr>
<tr>
<td align="left"><code>--size, -s</code></td>
<td align="left"><code>false</code></td>
<td align="left">显示总文件大小</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code>docker ps -n 5docker ps -a -q
</code></pre>
<h5 id="停止容器-重要"><a href="#停止容器-重要" class="headerlink" title="停止容器[重要]"></a>停止容器[重要]</h5><p>使用<code>docker stop</code> 命令，即可停止容器。</p>
<p>命令格式：</p>
<pre><code>docker stop [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--time, -t</code></td>
<td align="left"><code>10</code></td>
<td align="left">强制杀死容器前等待的时间，单位是秒</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code>docker stop 784fd3b294d7
</code></pre>
<p>其中<code>784fd3b294d7</code> 是容器ID，当然也可使用<code>docker stop 容器名称</code> 来停止指定容器。</p>
<h5 id="强制停止容器-重要"><a href="#强制停止容器-重要" class="headerlink" title="强制停止容器[重要]"></a>强制停止容器[重要]</h5><p>可使用<code>docker kill</code> 命令停止一个或更多运行着的容器。</p>
<p>命令格式：</p>
<pre><code>docker kill [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--signal, -s</code></td>
<td align="left"><code>KILL</code></td>
<td align="left">向容器发送一个信号</td>
</tr>
</tbody></table>
<p>例如：</p>
<pre><code>docker kill 784fd3b294d7
</code></pre>
<h5 id="启动已停止的容器-重要"><a href="#启动已停止的容器-重要" class="headerlink" title="启动已停止的容器[重要]"></a>启动已停止的容器[重要]</h5><p>使用<code>docker run</code> 命令，即可新建并启动一个容器。对于已停止的容器，可使用<code>docker start</code> 命令来启动。</p>
<p>命令格式：</p>
<pre><code>docker start [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--attach, -a</code></td>
<td align="left"><code>false</code></td>
<td align="left">连接<code>STDOUT/STDERR</code>并转发信号</td>
</tr>
<tr>
<td align="left"><code>--checkpoint</code></td>
<td align="left"></td>
<td align="left">从该检查点还原</td>
</tr>
<tr>
<td align="left"><code>--checkpoint-dir</code></td>
<td align="left"></td>
<td align="left">使用自定义的检查点存储目录</td>
</tr>
<tr>
<td align="left"><code>--detach-keys</code></td>
<td align="left"></td>
<td align="left">覆盖断开容器的关键顺序</td>
</tr>
<tr>
<td align="left"><code>--interactive, -i</code></td>
<td align="left"><code>false</code></td>
<td align="left">连接容器的<code>STDIN</code></td>
</tr>
</tbody></table>
<p>例如：</p>
<pre><code>docker start 784fd3b294d7
</code></pre>
<h5 id="重启容器-重要"><a href="#重启容器-重要" class="headerlink" title="重启容器[重要]"></a>重启容器[重要]</h5><p>可使用<code>docker restart</code> 命令来重启容器。该命令实际上是先执行了<code>docker stop</code> 命令，然后执行了<code>docker start</code> 命令。</p>
<p>命令格式：</p>
<pre><code>docker restart [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--time, -t</code></td>
<td align="left"><code>10</code></td>
<td align="left">关闭容器前等待的时间，单位是秒</td>
</tr>
</tbody></table>
<h5 id="进入容器-重要"><a href="#进入容器-重要" class="headerlink" title="进入容器[重要]"></a>进入容器[重要]</h5><p>某场景下，我们可能需要进入运行中的容器。</p>
<p>① 使用<code>docker attach</code> 命令进入容器。</p>
<p>例如：</p>
<pre><code>docker attach 784fd3b294d7
</code></pre>
<p>很多场景下，使用<code>docker attach</code> 命令并不方便。当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。同理，如果某个窗口发生阻塞，其他窗口也无法执行操作。</p>
<p>② 使用<code>nsenter</code> 进入容器</p>
<p><code>nsenter</code>工具包含在<code>util-linux 2.23</code>或更高版本中。为了连接到容器，我们需要找到容器第一个进程的<code>PID</code>，可通过以下命令获取：</p>
<pre><code>docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; $CONTAINER_ID
</code></pre>
<p>获得<code>PID</code>后，就可使用<code>nsenter</code>命令进入容器了：</p>
<pre><code>nsenter --target &quot;$PID&quot; --mount --uts --ipc --net --pid
</code></pre>
<p>下面给出一个完整的例子：</p>
<pre><code>[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES784fd3b294d7        nginx               &quot;nginx -g &#39;daemon off&quot;   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes[root@localhost ~]# docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; 784fd3b294d795492[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pidroot@784fd3b294d7:/#
</code></pre>
<p>读者也可将以上两条命令封装成一个Shell，从而简化进入容器的过程。</p>
<p>③ docker exec</p>
<pre><code>docker exec -it 容器id /bin/bash
</code></pre>
<h5 id="删除容器-重要"><a href="#删除容器-重要" class="headerlink" title="删除容器[重要]"></a>删除容器[重要]</h5><p>使用<code>docker rm</code> 命令即可删除指定容器。</p>
<p>命令格式</p>
<pre><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--force, -f</code></td>
<td align="left"><code>false</code></td>
<td align="left">通过<code>SIGKILL</code>信号强制删除正在运行中的容器</td>
</tr>
<tr>
<td align="left"><code>--link, -l</code></td>
<td align="left"><code>false</code></td>
<td align="left">删除容器间的网络连接</td>
</tr>
<tr>
<td align="left"><code>--volumes, -v</code></td>
<td align="left"><code>false</code></td>
<td align="left">删除与容器关联的卷</td>
</tr>
</tbody></table>
<p>例1：删除指定容器。</p>
<pre><code>docker rm 784fd3b294d7
</code></pre>
<p>该命令只能删除已停止的容器，如需删除正在运行的容器，可使用-f参数。</p>
<p>例2：删除所有的容器。</p>
<pre><code>docker rm -f $(docker ps -a -q)
</code></pre>
<h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><p>将容器导出成一个压缩包文件。</p>
<p>命令格式：</p>
<pre><code>docker export [OPTIONS] CONTAINER
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--output, -o</code></td>
<td align="left"></td>
<td align="left">将内容写到文件而非<code>STDOUT</code></td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code>docker export red_panda &gt; latest.tardocker export --output=&quot;latest.tar&quot; red_panda
</code></pre>
<h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5><p>使用<code>docker import</code> 命令即可从归档文件导入内容并创建镜像。</p>
<p>命令格式：</p>
<pre><code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]
</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--change, -c</code></td>
<td align="left"></td>
<td align="left">将<code>Dockerfile</code>指令应用到创建的镜像</td>
</tr>
<tr>
<td align="left"><code>--message, -m</code></td>
<td align="left"></td>
<td align="left">为导入的镜像设置提交信息</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code>docker import nginx2.tar nginx
</code></pre>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><h5 id="ADD-复制文件"><a href="#ADD-复制文件" class="headerlink" title="ADD 复制文件"></a>ADD 复制文件</h5><p>ADD复制文件</p>
<p>格式为：</p>
<ul>
<li><code>ADD &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li>
</ul>
<p>从<code>src</code>目录复制文件到容器的<code>dest</code>。其中<code>src</code>可以是<code>Dockerfile</code>所在目录的相对路径，也可以是一个URL，还可以是一个压缩包。</p>
<p>除了要复制解压文件，一般不建议使用，使用<code>RUN</code>跟<code>COPY</code>命令就可以很好替代。</p>
<pre><code class="dockerfile">ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jar
</code></pre>
<h5 id="ARG-设置构建参数"><a href="#ARG-设置构建参数" class="headerlink" title="ARG 设置构建参数"></a>ARG 设置构建参数</h5><p>设置构建参数，类似于<code>ENV</code>。和<code>ENV</code>不同的是，<code>ARG</code>设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。</p>
<p>格式为：</p>
<ul>
<li><code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></li>
</ul>
<pre><code class="dockerfile">ARG user1=someuser
</code></pre>
<h5 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h5><p>用于为执行容器提供默认值。每个<code>Dockerfile</code>只有一个<code>CMD</code>命令，如果指定了多个<code>CMD</code>命令，那么只有最后一条会被执行，如果启动容器的时候指定了运行的命令，则会覆盖掉<code>CMD</code>指定的命令。</p>
<p>支持三种格式：</p>
<p><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (推荐使用，会解析成json数组，所以要记得要用<strong>双引号</strong>)</p>
<p><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (为<code>ENTRYPOINT</code>指令提供预设参数)</p>
<p><code>CMD command param1 param2</code> (在shell中执行)</p>
<p>示例：</p>
<pre><code class="dockerfile">CMD echo &quot;This is a test.&quot; | wc -
</code></pre>
<h5 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h5><p>复制文件，格式为：</p>
<ul>
<li><code>COPY &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li>
</ul>
<p>复制本地端的<code>src</code>到容器的<code>dest</code>。<code>COPY</code>指令和<code>ADD</code>指令类似，<code>COPY</code>不支持URL和压缩包。</p>
<h5 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h5><p>格式为：</p>
<ul>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>
<li><code>ENTRYPOINT command param1 param2</code></li>
</ul>
<p><code>ENTRYPOINT</code>和<code>CMD</code>指令的目的一样，都是指定<code>Docker</code>容器启动时执行的命令，可多次设置，但只有最后一个有效。<code>ENTRYPOINT</code>不可被重写覆盖。</p>
<p><code>ENTRYPOINT</code>、<code>CMD</code>区别：<a target="_blank" rel="noopener" href="http://blog.csdn.net/newjueqi/article/details/51355510">http://blog.csdn.net/newjueqi/article/details/51355510</a></p>
<h5 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h5><p>用于设置环境变量，格式为：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key&gt;=&lt;value&gt; ...</code></li>
</ul>
<p>示例：</p>
<pre><code class="dockerfile">ENV JAVA_HOME /path/to/java
</code></pre>
<h5 id="EXPOSE-声明暴露的端口"><a href="#EXPOSE-声明暴露的端口" class="headerlink" title="EXPOSE 声明暴露的端口"></a>EXPOSE 声明暴露的端口</h5><p>用于声明在运行时容器提供服务的端口，格式为：</p>
<ul>
<li><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></li>
</ul>
<p>需要注意的是，这只是一个声明，运行时并不会因为该声明就打开相应端口。该指令的作用主要是帮助镜像使用者理解该镜像服务的守护端口；其次是当运行时使用随机映射时，会自动映射<code>EXPOSE</code>的端口。示例：</p>
<pre><code class="dockerfile"># 声明暴露一个端口示例
EXPOSE port1
# 相应的运行容器使用的命令
docker run -p port1 image
# 也可使用-P选项启动
docker run -P image
# 声明暴露多个端口示例
EXPOSE port1 port2 port3
# 相应的运行容器使用的命令
docker run -p port1 -p port2 -p port3 image
# 也可指定需要映射到宿主机器上的端口号  
docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image
</code></pre>
<h5 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h5><p>指定基础镜像，<code>FROM</code>指令有点像<code>Java</code>里面的<code>extend</code>关键字。需要注意的是，<code>FROM</code>指令必须指定且需要写在其他指令之前。<code>FROM</code>指令后的所有指令都依赖于该指令所指定的镜像。</p>
<p>支持三种格式：</p>
<ul>
<li><code>FROM &lt;image&gt;</code></li>
<li><code>FROM &lt;image&gt;:&lt;tag&gt;</code></li>
<li><code>FROM &lt;image&gt;@&lt;digest&gt;</code></li>
</ul>
<h5 id="LABEL-为镜像添加元数据"><a href="#LABEL-为镜像添加元数据" class="headerlink" title="LABEL 为镜像添加元数据"></a>LABEL 为镜像添加元数据</h5><p>为镜像添加元数据。</p>
<p>格式为：</p>
<ul>
<li><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li>
</ul>
<p>示例：</p>
<pre><code class="dockerfile">LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;
LABEL com.example.label-with-value=&quot;foo&quot;
LABEL version=&quot;1.0&quot;
LABEL description=&quot;This text illustrates \that label-values can span multiple lines.&quot;
</code></pre>
<h5 id="MAINTAINER-指定维护者的信息（已过时）"><a href="#MAINTAINER-指定维护者的信息（已过时）" class="headerlink" title="MAINTAINER 指定维护者的信息（已过时）"></a>MAINTAINER 指定维护者的信息（已过时）</h5><p>MAINTAINER指令用于指定维护者的信息，用于为<code>Dockerfile</code>署名。</p>
<p>格式为：</p>
<ul>
<li><code>MAINTAINER &lt;name&gt;</code></li>
</ul>
<p>示例：</p>
<pre><code class="dockerfile">MAINTAINER 周立&lt;eacdy0000@126.com&gt;
</code></pre>
<p>注：该指令已过时，建议使用如下形式：</p>
<pre><code class="dockerfile">LABEL maintainer=&quot;SvenDowideit@home.org.au&quot;
</code></pre>
<h5 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h5><p>该指令支持两种格式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code></li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>
</ul>
<p><code>RUN &lt;command&gt;</code> 在<code>shell</code>终端中运行，在<code>Linux</code>中默认是<code>/bin/sh -c</code> ，在<code>Windows</code>中是 <code>cmd /s /c</code>，使用这种格式，就像直接在命令行中输入命令一样。<br><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 使用exec执行，这种方式类似于函数调用。指定其他终端可以通过该方式操作，例如：<code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code> ，该方式必须使用双引号[“]而不能使用单引号[‘]，因为该方式会被转换成一个<code>JSON</code> 数组。</p>
<h5 id="USER-设置用户"><a href="#USER-设置用户" class="headerlink" title="USER 设置用户"></a>USER 设置用户</h5><p>该指令用于设置启动镜像时的用户或者<code>UID</code>，写在该指令后的<code>RUN</code>、<code>CMD</code>以及<code>ENTRYPOINT</code>指令都将使用该用户执行命令。</p>
<p>格式为：</p>
<ul>
<li><code>USER 用户名</code></li>
</ul>
<p>示例：</p>
<pre><code>USER daemon
</code></pre>
<h5 id="VOLUME-指定挂载点"><a href="#VOLUME-指定挂载点" class="headerlink" title="VOLUME 指定挂载点"></a>VOLUME 指定挂载点</h5><p>该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可共享给其他容器。当容器中的应用有持久化数据的需求时可以在<code>Dockerfile</code>中使用该指令。格式为：</p>
<ul>
<li><code>VOLUME [&quot;/data&quot;]</code></li>
</ul>
<p>示例：</p>
<pre><code>VOLUME /data
</code></pre>
<p>使用示例：</p>
<pre><code>FROM nginxVOLUME /tmp
</code></pre>
<p>当该<code>Dockerfile</code>被构建成镜像后，<code>/tmp</code>目录中的数据即使容器关闭也依然存在。如果另一个容器也有持久化的需求，并且想使用以上容器<code>/tmp</code>目录中的内容，则可使用如下命令启动容器：</p>
<pre><code>docker run -volume-from 容器ID 镜像名称  # 容器ID是di一个容器的ID，镜像是第二个容器所使用的镜像。
</code></pre>
<h5 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h5><p>格式为：</p>
<ul>
<li><code>WORKDIR /path/to/workdir</code></li>
</ul>
<p>切换目录指令，类似于<code>cd</code>命令，写在该指令后的<code>RUN</code>，<code>CMD</code>以及<code>ENTRYPOINT</code>指令都将该目录作为当前目录，并执行相应的命令。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><code>Dockerfile</code>还有一些其他的指令，例如<code>STOPSINGAL</code>、<code>HEALTHCHECK</code>、<code>SHELL</code>等。由于并不是很常用，本书不作赘述。有兴趣的读者可前往<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a> 扩展阅读。</p>
<p><strong>CMD/ENTRYPOINT/RUN区别</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000000417103">https://segmentfault.com/q/1010000000417103</a></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a target="_blank" rel="noopener" href="https://www.docker.com/">Docker官方网站</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/docker">Docker GitHub</a></p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice">Docker 入门到实践</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/xx/posts/65402be.html" title="YouMeek开展捐赠陪聊服务"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: YouMeek开展捐赠陪聊服务</span></a><a class="button is-default" href="/xx/posts/853e67f7.html" title="物种起源（全英文）"><span class="has-text-weight-semibold">下一页: 物种起源（全英文）</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/shelby86443093"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/xixi-cmd"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/chenshang-53"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> AIENS. 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/xx/js/post.js"></script></body></html>